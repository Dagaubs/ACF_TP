// Code generated by Isabelle
package tp67

import utilities.Datatype._
// automatic conversion of utilities.Datatype.Int.int to Int.int
object AutomaticConversion{ 
	implicit def int2int(i:utilities.Datatype.Int.int):Int.int =
			i match {
			case utilities.Datatype.Int.int_of_integer(i)=>Int.int_of_integer(i)
	}
}
import AutomaticConversion._


object HOL {

trait equal[A] {
  val `HOL.equal`: (A, A) => Boolean
}
def equal[A](a: A, b: A)(implicit A: equal[A]): Boolean = A.`HOL.equal`(a, b)
object equal {
  implicit def `String.equal_char`: equal[String.char] = new equal[String.char]
    {
    val `HOL.equal` = (a: String.char, b: String.char) =>
      String.equal_chara(a, b)
  }
  implicit def `Lista.equal_list`[A : equal]: equal[List[A]] = new
    equal[List[A]] {
    val `HOL.equal` = (a: List[A], b: List[A]) => Lista.equal_lista[A](a, b)
  }
}

def eq[A : equal](a: A, b: A): Boolean = equal[A](a, b)

} /* object HOL */

object Nat {

abstract sealed class nat
final case class zero_nat() extends nat
final case class Suc(a: nat) extends nat

def one_nat: nat = Suc(zero_nat())

def less_eq_nat(x0: nat, n: nat): Boolean = (x0, n) match {
  case (Suc(m), n) => less_nat(m, n)
  case (zero_nat(), n) => true
}

def less_nat(m: nat, x1: nat): Boolean = (m, x1) match {
  case (m, Suc(n)) => less_eq_nat(m, n)
  case (n, zero_nat()) => false
}

def plus_nat(x0: nat, n: nat): nat = (x0, n) match {
  case (Suc(m), n) => plus_nat(m, Suc(n))
  case (zero_nat(), n) => n
}

def equal_nat(x0: nat, x1: nat): Boolean = (x0, x1) match {
  case (zero_nat(), Suc(x2)) => false
  case (Suc(x2), zero_nat()) => false
  case (Suc(x2), Suc(y2)) => equal_nat(x2, y2)
  case (zero_nat(), zero_nat()) => true
}

def minus_nat(m: nat, n: nat): nat = (m, n) match {
  case (Suc(m), Suc(n)) => minus_nat(m, n)
  case (zero_nat(), n) => zero_nat()
  case (m, zero_nat()) => m
}

} /* object Nat */

object Num {

abstract sealed class num
final case class One() extends num
final case class Bit0(a: num) extends num
final case class Bit1(a: num) extends num

def nat_of_num(x0: num): Nat.nat = x0 match {
  case Bit1(n) => {
                    val m: Nat.nat = nat_of_num(n);
                    Nat.Suc(Nat.plus_nat(m, m))
                  }
  case Bit0(n) => {
                    val m: Nat.nat = nat_of_num(n);
                    Nat.plus_nat(m, m)
                  }
  case One() => Nat.one_nat
}

def less_eq_num(x0: num, n: num): Boolean = (x0, n) match {
  case (Bit1(m), Bit0(n)) => less_num(m, n)
  case (Bit1(m), Bit1(n)) => less_eq_num(m, n)
  case (Bit0(m), Bit1(n)) => less_eq_num(m, n)
  case (Bit0(m), Bit0(n)) => less_eq_num(m, n)
  case (Bit1(m), One()) => false
  case (Bit0(m), One()) => false
  case (One(), n) => true
}

def less_num(m: num, x1: num): Boolean = (m, x1) match {
  case (Bit1(m), Bit0(n)) => less_num(m, n)
  case (Bit1(m), Bit1(n)) => less_num(m, n)
  case (Bit0(m), Bit1(n)) => less_eq_num(m, n)
  case (Bit0(m), Bit0(n)) => less_num(m, n)
  case (One(), Bit1(n)) => true
  case (One(), Bit0(n)) => true
  case (m, One()) => false
}

def equal_num(x0: num, x1: num): Boolean = (x0, x1) match {
  case (Bit0(x2), Bit1(x3)) => false
  case (Bit1(x3), Bit0(x2)) => false
  case (One(), Bit1(x3)) => false
  case (Bit1(x3), One()) => false
  case (One(), Bit0(x2)) => false
  case (Bit0(x2), One()) => false
  case (Bit1(x3), Bit1(y3)) => equal_num(x3, y3)
  case (Bit0(x2), Bit0(y2)) => equal_num(x2, y2)
  case (One(), One()) => true
}

} /* object Num */

object Int {

abstract sealed class int
final case class zero_int() extends int
final case class Pos(a: Num.num) extends int
final case class Neg(a: Num.num) extends int

def less_int(x0: int, x1: int): Boolean = (x0, x1) match {
  case (Neg(k), Neg(l)) => Num.less_num(l, k)
  case (Neg(k), Pos(l)) => true
  case (Neg(k), zero_int()) => true
  case (Pos(k), Neg(l)) => false
  case (Pos(k), Pos(l)) => Num.less_num(k, l)
  case (Pos(k), zero_int()) => false
  case (zero_int(), Neg(l)) => false
  case (zero_int(), Pos(l)) => true
  case (zero_int(), zero_int()) => false
}

def equal_int(x0: int, x1: int): Boolean = (x0, x1) match {
  case (Neg(k), Neg(l)) => Num.equal_num(k, l)
  case (Neg(k), Pos(l)) => false
  case (Neg(k), zero_int()) => false
  case (Pos(k), Neg(l)) => false
  case (Pos(k), Pos(l)) => Num.equal_num(k, l)
  case (Pos(k), zero_int()) => false
  case (zero_int(), Neg(l)) => false
  case (zero_int(), Pos(l)) => false
  case (zero_int(), zero_int()) => true
}

} /* object Int */

object Product_Type {

def snd[A, B](x0: (A, B)): B = x0 match {
  case (x1, x2) => x2
}

} /* object Product_Type */

object Divides {

def divmod_nat(m: Nat.nat, n: Nat.nat): (Nat.nat, Nat.nat) =
  (if (Nat.equal_nat(n, Nat.zero_nat()) || Nat.less_nat(m, n))
    (Nat.zero_nat(), m)
    else {
           val a: (Nat.nat, Nat.nat) = divmod_nat(Nat.minus_nat(m, n), n)
           val (q, aa): (Nat.nat, Nat.nat) = a;
           (Nat.Suc(q), aa)
         })

def modulo_nat(m: Nat.nat, n: Nat.nat): Nat.nat =
  Product_Type.snd[Nat.nat, Nat.nat](divmod_nat(m, n))

} /* object Divides */

object String {

abstract sealed class char
final case class zero_char() extends char
final case class Char(a: Num.num) extends char

def equal_chara(x0: char, x1: char): Boolean = (x0, x1) match {
  case (Char(k), zero_char()) =>
    Nat.equal_nat(Divides.modulo_nat(Num.nat_of_num(k),
                                      Num.nat_of_num(Num.Bit0(Num.Bit0(Num.Bit0(Num.Bit0(Num.Bit0(Num.Bit0(Num.Bit0(Num.Bit0(Num.One())))))))))),
                   Nat.zero_nat())
  case (zero_char(), Char(k)) =>
    Nat.equal_nat(Divides.modulo_nat(Num.nat_of_num(k),
                                      Num.nat_of_num(Num.Bit0(Num.Bit0(Num.Bit0(Num.Bit0(Num.Bit0(Num.Bit0(Num.Bit0(Num.Bit0(Num.One())))))))))),
                   Nat.zero_nat())
  case (Char(k), Char(l)) =>
    Nat.equal_nat(Divides.modulo_nat(Num.nat_of_num(k),
                                      Num.nat_of_num(Num.Bit0(Num.Bit0(Num.Bit0(Num.Bit0(Num.Bit0(Num.Bit0(Num.Bit0(Num.Bit0(Num.One())))))))))),
                   Divides.modulo_nat(Num.nat_of_num(l),
                                       Num.nat_of_num(Num.Bit0(Num.Bit0(Num.Bit0(Num.Bit0(Num.Bit0(Num.Bit0(Num.Bit0(Num.Bit0(Num.One())))))))))))
  case (zero_char(), zero_char()) => true
}

} /* object String */

object Lista {

def equal_lista[A : HOL.equal](x0: List[A], x1: List[A]): Boolean = (x0, x1)
  match {
  case (Nil, x21 :: x22) => false
  case (x21 :: x22, Nil) => false
  case (x21 :: x22, y21 :: y22) =>
    HOL.eq[A](x21, y21) && equal_lista[A](x22, y22)
  case (Nil, Nil) => true
}

} /* object Lista */

object tp67 {

abstract sealed class absInt
final case class Neg() extends absInt
final case class Zero() extends absInt
final case class NonZero() extends absInt
final case class Pos() extends absInt
final case class Undef() extends absInt
final case class Any() extends absInt

abstract sealed class option[A]
final case class Nonea[A]() extends option[A]
final case class Somea[A](a: A) extends option[A]

def equal_absInt(x0: absInt, x1: absInt): Boolean = (x0, x1) match {
  case (Undef(), Any()) => false
  case (Any(), Undef()) => false
  case (Pos(), Any()) => false
  case (Any(), Pos()) => false
  case (Pos(), Undef()) => false
  case (Undef(), Pos()) => false
  case (NonZero(), Any()) => false
  case (Any(), NonZero()) => false
  case (NonZero(), Undef()) => false
  case (Undef(), NonZero()) => false
  case (NonZero(), Pos()) => false
  case (Pos(), NonZero()) => false
  case (Zero(), Any()) => false
  case (Any(), Zero()) => false
  case (Zero(), Undef()) => false
  case (Undef(), Zero()) => false
  case (Zero(), Pos()) => false
  case (Pos(), Zero()) => false
  case (Zero(), NonZero()) => false
  case (NonZero(), Zero()) => false
  case (Neg(), Any()) => false
  case (Any(), Neg()) => false
  case (Neg(), Undef()) => false
  case (Undef(), Neg()) => false
  case (Neg(), Pos()) => false
  case (Pos(), Neg()) => false
  case (Neg(), NonZero()) => false
  case (NonZero(), Neg()) => false
  case (Neg(), Zero()) => false
  case (Zero(), Neg()) => false
  case (Any(), Any()) => true
  case (Undef(), Undef()) => true
  case (Pos(), Pos()) => true
  case (NonZero(), NonZero()) => true
  case (Zero(), Zero()) => true
  case (Neg(), Neg()) => true
}

def priorities(x0: absInt, uu: absInt): absInt = (x0, uu) match {
  case (Undef(), uu) => Undef()
  case (Neg(), Undef()) => Undef()
  case (Zero(), Undef()) => Undef()
  case (NonZero(), Undef()) => Undef()
  case (Pos(), Undef()) => Undef()
  case (Any(), Undef()) => Undef()
  case (Neg(), Neg()) => (if (equal_absInt(Neg(), Neg())) Neg() else Any())
  case (Neg(), Zero()) => (if (equal_absInt(Neg(), Zero())) Neg() else Any())
  case (Neg(), NonZero()) =>
    (if (equal_absInt(Neg(), NonZero())) Neg() else Any())
  case (Neg(), Pos()) => (if (equal_absInt(Neg(), Pos())) Neg() else Any())
  case (Neg(), Any()) => (if (equal_absInt(Neg(), Any())) Neg() else Any())
  case (Zero(), Neg()) => (if (equal_absInt(Zero(), Neg())) Zero() else Any())
  case (Zero(), Zero()) => (if (equal_absInt(Zero(), Zero())) Zero() else Any())
  case (Zero(), NonZero()) =>
    (if (equal_absInt(Zero(), NonZero())) Zero() else Any())
  case (Zero(), Pos()) => (if (equal_absInt(Zero(), Pos())) Zero() else Any())
  case (Zero(), Any()) => (if (equal_absInt(Zero(), Any())) Zero() else Any())
  case (NonZero(), Neg()) =>
    (if (equal_absInt(NonZero(), Neg())) NonZero() else Any())
  case (NonZero(), Zero()) =>
    (if (equal_absInt(NonZero(), Zero())) NonZero() else Any())
  case (NonZero(), NonZero()) =>
    (if (equal_absInt(NonZero(), NonZero())) NonZero() else Any())
  case (NonZero(), Pos()) =>
    (if (equal_absInt(NonZero(), Pos())) NonZero() else Any())
  case (NonZero(), Any()) =>
    (if (equal_absInt(NonZero(), Any())) NonZero() else Any())
  case (Pos(), Neg()) => (if (equal_absInt(Pos(), Neg())) Pos() else Any())
  case (Pos(), Zero()) => (if (equal_absInt(Pos(), Zero())) Pos() else Any())
  case (Pos(), NonZero()) =>
    (if (equal_absInt(Pos(), NonZero())) Pos() else Any())
  case (Pos(), Pos()) => (if (equal_absInt(Pos(), Pos())) Pos() else Any())
  case (Pos(), Any()) => (if (equal_absInt(Pos(), Any())) Pos() else Any())
  case (Any(), Neg()) => (if (equal_absInt(Any(), Neg())) Any() else Any())
  case (Any(), Zero()) => (if (equal_absInt(Any(), Zero())) Any() else Any())
  case (Any(), NonZero()) =>
    (if (equal_absInt(Any(), NonZero())) Any() else Any())
  case (Any(), Pos()) => (if (equal_absInt(Any(), Pos())) Any() else Any())
  case (Any(), Any()) => (if (equal_absInt(Any(), Any())) Any() else Any())
}

def assoc[A : HOL.equal, B](uu: A, x1: List[(A, B)]): option[B] = (uu, x1) match
  {
  case (uu, Nil) => Nonea[B]()
  case (x1, (x, y) :: xs) =>
    (if (HOL.eq[A](x, x1)) Somea[B](y) else assoc[A, B](x1, xs))
}

def mergeTwoAbsSymTable(t1: List[(List[String.char], absInt)],
                         x1: List[(List[String.char], absInt)]):
      List[(List[String.char], absInt)]
  =
  (t1, x1) match {
  case (t1, (x2, y2) :: t2) =>
    (assoc[List[String.char], absInt](x2, t1) match {
       case Nonea() => mergeTwoAbsSymTable((x2, y2) :: t1, t2)
       case Somea(r) => mergeTwoAbsSymTable((x2, priorities(y2, r)) :: t1, t2)
     })
  case ((x1, y1) :: t1, Nil) => (x1, y1) :: t1
  case (Nil, Nil) => Nil
}

def toAbs(x: Int.int): absInt =
  (if (Int.equal_int(x, Int.zero_int())) Zero()
    else (if (Int.less_int(Int.zero_int(), x)) Pos() else Neg()))

def evalCondition(x0: condition): (option[List[String.char]], (absInt, absInt))
  =
  x0 match {
  case Eq(Variable(x), Constant(c)) =>
    (toAbs(c) match {
       case Neg() => (Somea[List[String.char]](x), (toAbs(c), Any()))
       case Zero() => (Somea[List[String.char]](x), (Zero(), NonZero()))
       case NonZero() => (Somea[List[String.char]](x), (toAbs(c), Any()))
       case Pos() => (Somea[List[String.char]](x), (toAbs(c), Any()))
       case Undef() => (Somea[List[String.char]](x), (toAbs(c), Any()))
       case Any() => (Somea[List[String.char]](x), (toAbs(c), Any()))
     })
  case Eq(Constant(vb), va) => (Nonea[List[String.char]](), (Any(), Any()))
  case Eq(Sum(vb, vc), va) => (Nonea[List[String.char]](), (Any(), Any()))
  case Eq(Sub(vb, vc), va) => (Nonea[List[String.char]](), (Any(), Any()))
  case Eq(v, Variable(vb)) => (Nonea[List[String.char]](), (Any(), Any()))
  case Eq(v, Sum(vb, vc)) => (Nonea[List[String.char]](), (Any(), Any()))
  case Eq(v, Sub(vb, vc)) => (Nonea[List[String.char]](), (Any(), Any()))
}

def absMinus(uu: absInt, x1: absInt): absInt = (uu, x1) match {
  case (uu, Any()) => Any()
  case (Any(), Neg()) => Any()
  case (Any(), Zero()) => Any()
  case (Any(), NonZero()) => Any()
  case (Any(), Pos()) => Any()
  case (Any(), Undef()) => Any()
  case (Undef(), Neg()) => Undef()
  case (Undef(), Zero()) => Undef()
  case (Undef(), NonZero()) => Undef()
  case (Undef(), Pos()) => Undef()
  case (Undef(), Undef()) => Undef()
  case (Neg(), Undef()) => Undef()
  case (Zero(), Undef()) => Undef()
  case (NonZero(), Undef()) => Undef()
  case (Pos(), Undef()) => Undef()
  case (Pos(), Pos()) => Any()
  case (Pos(), Neg()) => Pos()
  case (Neg(), Pos()) => Neg()
  case (Neg(), Neg()) => Any()
  case (Neg(), Zero()) => Neg()
  case (Zero(), Zero()) => Zero()
  case (NonZero(), Zero()) => NonZero()
  case (Pos(), Zero()) => Pos()
  case (Zero(), Pos()) => Neg()
  case (Zero(), Neg()) => Pos()
  case (NonZero(), NonZero()) => NonZero()
  case (NonZero(), Neg()) => Any()
  case (NonZero(), Pos()) => Any()
  case (Neg(), NonZero()) => Any()
  case (Zero(), NonZero()) => Any()
  case (Pos(), NonZero()) => Any()
}

def absPlus(uu: absInt, x1: absInt): absInt = (uu, x1) match {
  case (uu, Any()) => Any()
  case (Any(), Neg()) => Any()
  case (Any(), Zero()) => Any()
  case (Any(), NonZero()) => Any()
  case (Any(), Pos()) => Any()
  case (Any(), Undef()) => Any()
  case (Undef(), Neg()) => Undef()
  case (Undef(), Zero()) => Undef()
  case (Undef(), NonZero()) => Undef()
  case (Undef(), Pos()) => Undef()
  case (Undef(), Undef()) => Undef()
  case (Neg(), Undef()) => Undef()
  case (Zero(), Undef()) => Undef()
  case (NonZero(), Undef()) => Undef()
  case (Pos(), Undef()) => Undef()
  case (Pos(), Pos()) => Pos()
  case (Pos(), Neg()) => Any()
  case (Neg(), Pos()) => Any()
  case (Neg(), Neg()) => Neg()
  case (Neg(), Zero()) => Neg()
  case (Zero(), Zero()) => Zero()
  case (NonZero(), Zero()) => NonZero()
  case (Pos(), Zero()) => Pos()
  case (Zero(), Neg()) => Neg()
  case (Zero(), NonZero()) => NonZero()
  case (Zero(), Pos()) => Pos()
  case (NonZero(), NonZero()) => NonZero()
  case (NonZero(), Neg()) => Any()
  case (NonZero(), Pos()) => Any()
  case (Neg(), NonZero()) => Any()
  case (Pos(), NonZero()) => Any()
}

def evalEAbs(x0: expression, t: List[(List[String.char], absInt)]): absInt =
  (x0, t) match {
  case (Constant(s), t) => toAbs(s)
  case (Variable(s), t) => (assoc[List[String.char], absInt](s, t) match {
                              case Nonea() => Undef()
                              case Somea(y) => y
                            })
  case (Sum(e1, e2), t) => absPlus(evalEAbs(e1, t), evalEAbs(e2, t))
  case (Sub(e1, e2), t) => absMinus(evalEAbs(e1, t), evalEAbs(e2, t))
}

def evalAbsInt(uu: absInt, uv: absInt): absInt = (uu, uv) match {
  case (Zero(), Zero()) => Pos()
  case (Zero(), Pos()) => Neg()
  case (Zero(), Neg()) => Neg()
  case (Pos(), Zero()) => Neg()
  case (Neg(), Zero()) => Neg()
  case (NonZero(), Zero()) => Neg()
  case (Zero(), NonZero()) => Neg()
  case (Pos(), NonZero()) => Pos()
  case (Neg(), NonZero()) => Pos()
  case (Neg(), Neg()) => Zero()
  case (Neg(), Pos()) => Zero()
  case (Neg(), Undef()) => Zero()
  case (Neg(), Any()) => Zero()
  case (NonZero(), Neg()) => Zero()
  case (NonZero(), NonZero()) => Zero()
  case (NonZero(), Pos()) => Zero()
  case (NonZero(), Undef()) => Zero()
  case (NonZero(), Any()) => Zero()
  case (Pos(), Neg()) => Zero()
  case (Pos(), Pos()) => Zero()
  case (Pos(), Undef()) => Zero()
  case (Pos(), Any()) => Zero()
  case (Undef(), uv) => Zero()
  case (Any(), uv) => Zero()
  case (uu, Undef()) => Zero()
  case (uu, Any()) => Zero()
}

def evalCAbs(x0: condition, t: List[(List[String.char], absInt)]): absInt =
  (x0, t) match {
  case (Eq(e1, e2), t) => evalAbsInt(evalEAbs(e1, t), evalEAbs(e2, t))
}

def evalSAbs(x0: statement, t: List[(List[String.char], absInt)]):
      (List[(List[String.char], absInt)], Boolean)
  =
  (x0, t) match {
  case (Skip, t) => (t, true)
  case (Aff(s, e), t) => ((s, evalEAbs(e, t)) :: t, true)
  case (If(c, s1, s2), t) =>
    (evalCAbs(c, t) match {
       case Neg() => evalSAbs(s2, t)
       case Zero() =>
         (evalCondition(c) match {
            case (Nonea(), (_, _)) =>
              {
                val (t1, b1): (List[(List[String.char], absInt)], Boolean) =
                  evalSAbs(s1, t)
                val (t2, b2): (List[(List[String.char], absInt)], Boolean) =
                  evalSAbs(s2, t);
                (mergeTwoAbsSymTable(t1, t2), b1 && b2)
              }
            case (Somea(x), (a1, a2)) =>
              {
                val (t1, b1): (List[(List[String.char], absInt)], Boolean) =
                  evalSAbs(s1, (x, a1) :: t)
                val (t2, b2): (List[(List[String.char], absInt)], Boolean) =
                  evalSAbs(s2, (x, a2) :: t);
                (mergeTwoAbsSymTable(t1, t2), b1 && b2)
              }
          })
       case Pos() => evalSAbs(s1, t)
     })
  case (Seq(s1, s2), t) =>
    {
      val (t1, b1): (List[(List[String.char], absInt)], Boolean) =
        evalSAbs(s1, t)
      val (t2, b2): (List[(List[String.char], absInt)], Boolean) =
        evalSAbs(s2, t1);
      (t2, b1 && b2)
    }
  case (Read(s), t) => ((s, Any()) :: t, true)
  case (Print(e), t) => (t, true)
  case (Exec(e), t) => (evalEAbs(e, t) match {
                          case Neg() => (t, true)
                          case Zero() => (t, false)
                          case NonZero() => (t, true)
                          case Pos() => (t, true)
                          case Undef() => (t, false)
                          case Any() => (t, false)
                        })
}

def san3(s: statement): Boolean =
  {
    val (_, x): (List[(List[String.char], absInt)], Boolean) = evalSAbs(s, Nil);
    x
  }

} /* object tp67 */
