// Code generated by Isabelle
package TP5


object HOL {

trait equal[A] {
  val `HOL.equal`: (A, A) => Boolean
}
def equal[A](a: A, b: A)(implicit A: equal[A]): Boolean = A.`HOL.equal`(a, b)

def eq[A : equal](a: A, b: A): Boolean = equal[A](a, b)

} /* object HOL */

object Nat {

abstract sealed class nat
final case class zero_nat() extends nat
final case class Suc(a: nat) extends nat

def equal_nat(x0: nat, x1: nat): Boolean = (x0, x1) match {
  case (zero_nat(), Suc(x2)) => false
  case (Suc(x2), zero_nat()) => false
  case (Suc(x2), Suc(y2)) => equal_nat(x2, y2)
  case (zero_nat(), zero_nat()) => true
}

} /* object Nat */

object Lista {

def gen_length[A](n: Nat.nat, x1: List[A]): Nat.nat = (n, x1) match {
  case (n, x :: xs) => gen_length[A](Nat.Suc(n), xs)
  case (n, Nil) => n
}

def size_list[A]: (List[A]) => Nat.nat =
  (a: List[A]) => gen_length[A](Nat.zero_nat(), a)

} /* object Lista */

object tp5 {

def exactSubSeq[A : HOL.equal](x0: List[A], uu: List[A]): Boolean = (x0, uu)
  match {
  case (Nil, uu) => true
  case (v :: va, Nil) => false
  case (x1 :: l1s, x2 :: l2s) =>
    (if (HOL.eq[A](x1, x2)) exactSubSeq[A](l1s, l2s)
      else exactSubSeq[A](x1 :: l1s, l2s))
}

def subSeq[A : HOL.equal](x0: List[A], l2: List[A]): Boolean = (x0, l2) match {
  case (Nil, l2) => true
  case (x1 :: l1, Nil) =>
    Nat.equal_nat(Lista.size_list[A].apply(l1), Nat.zero_nat())
  case (x1 :: l1s, x2 :: l2s) =>
    (if (HOL.eq[A](x1, x2)) subSeq[A](l1s, l2s)
      else subSeq[A](x1 :: l1s, l2s) || exactSubSeq[A](l1s, x2 :: l2s))
}

} /* object tp5 */
